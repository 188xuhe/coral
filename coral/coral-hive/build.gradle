apply plugin:'li-java'
apply plugin: 'maven'
apply plugin: 'com.github.johnrengelman.shadow'

dependencies {
  compile (spec.product.hive.'hive-exec') {
    // Exclude calcite. We want to use newer version
    exclude group: 'org.apache.calcite', module: 'calcite-core'
    // avro-tools brings in hadoop-core package files causing duplicate jars and runtime errors
    exclude group: 'org.apache.avro', module: 'avro-tools'
  }
  compile spec.product.hadoop.'hadoop-mapreduce-client-common'
  compile spec.product.hadoop.'hadoop-auth'
  compile spec.external.'calcite-core'
  compile spec.external.'avatica-core'
  compile spec.external.'calcite-avatica'
}

def pomPath = "$buildDir/${name}.pom"

task createPom {
  doLast {
    pom {
      project {
        groupId "$project.group"
        artifactId "$project.name"
      }
      scopeMappings.mappings.remove(project.configurations.compile)
      scopeMappings.mappings.remove(project.configurations.runtime)
      scopeMappings.addMapping(MavenPlugin.RUNTIME_PRIORITY, project.configurations.shadow, Conf2ScopeMappingContainer.RUNTIME)
    }.writeTo("$pomPath")
  }
}

shadowJar {
  // classifier = ''
  zip64 true
}

// shadow plugin tries to upload pom if the maven plugin is also applied.
// We need this to silence those errors
uploadShadow.enabled = false
uploadShadow {
  repositories {
    mavenDeployer {
      mavenLocal()
    }
  }
}

// need to explicitly set this because we are generating pom files
generateModuleArtifactSpec.defaultArtifact = jar

artifacts {
  archives file: file("$pomPath"), name: "$name", type: "pom", builtBy: createPom
  archives jar, shadowJar, javadocJar, sourcesJar
}
