package com.linkedin.coral.spark;

import org.apache.calcite.sql.SqlBasicTypeNameSpec;
import org.apache.calcite.sql.SqlCall;
import org.apache.calcite.sql.SqlDataTypeSpec;
import org.apache.calcite.sql.SqlKind;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql.SqlRowTypeSpec;
import org.apache.calcite.sql.parser.SqlParserPos;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.calcite.sql.util.SqlShuttle;

/**
 * This class makes Spark changes in AST generated by RelToSparkSQLConverter
 *
 * This is the Second last Step in translation pipeline.
 * There may be AST manipulation logic here.
 */
public class SparkSqlRewriter extends SqlShuttle {

  /**
   *  [LIHADOOP-43199] Spark SQL doesn't support CASTING the named_struct function to a row/struct.
   *  Sushant suggests that we remove this behavior here.
   *
   *  For example:
   *
   *  @code SELECT CAST(named_struct(.....) to ROW)
   *   is translated to
   *  @code SELECT named_struct(.....)
   *
   */
  @Override
  public SqlNode visit(SqlCall call) {
    // Spark SQL doesn't support CASTING the named_struct function TO A ROW.
    // Keeping the expression inside CAST operator seems sufficient.
    if (call.getOperator().getKind() == SqlKind.CAST
        && call.getOperandList().get(1) instanceof SqlRowTypeSpec) {
      return call.getOperandList().get(0).accept(this);
    }
    return super.visit(call);
  }

  /**
   *  Spark SQL historically supported VARCHAR but latest documentation doesn't support it.
   *
   *  Source: https://spark.apache.org/docs/latest/sql-reference.html
   *  We convert a VARCHAR datatype to a STRING
   *
   */
  @Override
  public SqlNode visit(SqlDataTypeSpec type) {
    // Spark Sql Types are listed here: https://spark.apache.org/docs/latest/sql-reference.html
    assert type.getTypeNameSpec() instanceof SqlBasicTypeNameSpec;
    final SqlBasicTypeNameSpec typeNameSpec = (SqlBasicTypeNameSpec) type.getTypeNameSpec();
    final SqlParserPos parserPos = type.getParserPosition();
    switch (type.getTypeName().toString()) {
      case "VARCHAR":
        final SqlBasicTypeNameSpec stringTypeName = new SqlBasicTypeNameSpec(
            "STRING",
            SqlTypeName.VARCHAR,
            -1,
            typeNameSpec.getScale(),
            typeNameSpec.getCharSetName(),
            parserPos);
        return new SqlDataTypeSpec(stringTypeName, type.getTimeZone(), parserPos);
      default:
        return type;
    }
  }
}